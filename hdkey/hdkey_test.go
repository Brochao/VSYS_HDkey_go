package hdkey

import (
	"encoding/hex"
	"fmt"
	"testing"
)

func Test_HD_process(t *testing.T) {

	//  steps to use

	//  a seed for each wallet, take 32 bytes for example
	seed := []byte{0x7a, 0xd1, 0xdf, 0x7c, 0x25, 0x13, 0xa5, 0xbe, 0xfe, 0x3e, 0x65, 0x2d, 0xcd, 0x1b, 0x67, 0xe2, 0x48, 0x40, 0x3c, 0x22, 0xd4, 0xc1, 0x55, 0x0e, 0x17, 0x1d, 0xf4, 0x6c, 0xea, 0xa3, 0x91, 0x35}
	// path to derived keys , take  m/66'/33'/1'/3/0  for example
	// m/ refer to root key
	// ' means hardended derived
	path := "m/66'/33'/1'/3/0"

	// 1.  to derived key at path  m/66'/33'/1'/3/0 , the parent public key shoud be derived first,
	//     which means the public key at path m/66'/33'/1'/3 .
	parentPath := "m/66'/33'/1'/3"
	parentPub, err := GenerateParentPublicKey(seed, parentPath)
	if err != nil {
		t.Error("Generate parent public key failed with:", err)
	} else {
		fmt.Println("--------public key information at path m/66'/33'/1'/3--------")
		fmt.Println(parentPub)
	}

	// 2.   The information of parent public key is encoded with base58,
	//      when generate new addresses, only parentPub is needed,
	//      the wallet only need to save parentPub's information and the path generated it.

	// 3.   generate public key at m/66'/33'/1'/3/0,
	//      which is the first child key of parentPub
	childPub_0, err := GenerateChildPublicKeyBytes(parentPub, 0)
	if err != nil {
		t.Error("Generate child public key failed with:", err)
	} else {
		fmt.Println("--------child pubkey information at path m/66'/33'/1'/3/0--------")
		fmt.Println(hex.EncodeToString(childPub_0))
	}

	// 4. There's no need to use seed or any private keys to generate a new address,
	//    only when spending VSYS coins , the seed and the corresponding path is needed to get the private key
	//    the absolute path of publicKey_0 is m/66'/33'/1'/3/0
	childPri_0, err := GeneratePrivateKeyBytes(seed, path)
	if err != nil {
		t.Error("Generate child private key failed with:", err)
	} else {
		fmt.Println("--------child prikey information at path m/66'/33'/1'/3/0--------")
		fmt.Println(hex.EncodeToString(childPri_0))
	}

	// 5. Tons of public key points can be generated by changing the value of index,
	fmt.Println("--------VSYS public key points from index 1 to 999--------")
	for index := uint32(1); index < 1000; index++ {
		fmt.Println("--------index: ", index, " --------")
		childPub, err := GenerateChildPublicKeyBytes(parentPub, index)
		if err != nil {
			t.Error("Generate parent public key failed with:", err)
		} else {
			fmt.Println(hex.EncodeToString(childPub))
		}

	}
}
